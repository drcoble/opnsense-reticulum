name: Integration Tests

on:
  pull_request:
    branches: [testing]
  workflow_dispatch:

jobs:
  integration-test:
    name: OPNsense Integration Test
    runs-on: [self-hosted, opnsense-test]
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Python test dependencies
        run: |
          python3 -m venv .venv
          .venv/bin/pip install -r tests/requirements-test.txt

      - name: Restore OPNsense VM to clean snapshot
        env:
          PROXMOX_HOST: ${{ secrets.PROXMOX_HOST }}
          PROXMOX_TOKEN_ID: ${{ secrets.PROXMOX_TOKEN_ID }}
          PROXMOX_TOKEN_SECRET: ${{ secrets.PROXMOX_TOKEN_SECRET }}
          PROXMOX_NODE: ${{ secrets.PROXMOX_NODE }}
          PROXMOX_VM_ID: ${{ secrets.PROXMOX_VM_ID }}
          PROXMOX_SNAPSHOT: ${{ secrets.PROXMOX_SNAPSHOT }}
        run: |
          python3 << 'EOF'
          import os, sys, json, time, urllib.request, urllib.parse, ssl

          ctx = ssl.create_default_context()
          ctx.check_hostname = False
          ctx.verify_mode = ssl.CERT_NONE

          base  = f"https://{os.environ['PROXMOX_HOST']}:8006/api2/json"
          auth  = f"PVEAPIToken={os.environ['PROXMOX_TOKEN_ID']}={os.environ['PROXMOX_TOKEN_SECRET']}"
          node  = os.environ['PROXMOX_NODE']
          vmid  = os.environ['PROXMOX_VM_ID']
          snap  = os.environ['PROXMOX_SNAPSHOT']

          def api(method, path, data=None):
              req = urllib.request.Request(
                  f"{base}{path}",
                  data=data.encode() if data else None,
                  method=method,
                  headers={"Authorization": auth,
                           **({"Content-Type": "application/x-www-form-urlencoded"} if data else {})}
              )
              with urllib.request.urlopen(req, context=ctx) as r:
                  return json.loads(r.read())

          # List snapshots to verify names
          print(f"Checking snapshots for VM {vmid} on node '{node}'...")
          snaps = api("GET", f"/nodes/{node}/qemu/{vmid}/snapshot")
          names = [s["name"] for s in snaps.get("data", [])]
          print(f"Available snapshots: {names}")
          if snap not in names:
              print(f"ERROR: snapshot '{snap}' not found. Available: {names}")
              sys.exit(1)

          # Stop VM (ignore errors â€” may already be stopped)
          print(f"Stopping VM {vmid}...")
          try:
              api("POST", f"/nodes/{node}/qemu/{vmid}/status/stop", "timeout=30")
          except Exception as e:
              print(f"  (stop: {e})")
          time.sleep(15)

          # Rollback
          print(f"Rolling back to '{snap}'...")
          result = api("POST", f"/nodes/{node}/qemu/{vmid}/snapshot/{snap}/rollback")
          print(f"  task: {result.get('data')}")
          time.sleep(30)

          # Start VM
          print(f"Starting VM {vmid}...")
          result = api("POST", f"/nodes/{node}/qemu/{vmid}/status/start")
          print(f"  task: {result.get('data')}")
          EOF

      - name: Wait for OPNsense API
        env:
          OPNSENSE_HOST: ${{ secrets.OPNSENSE_HOST }}
          OPNSENSE_API_KEY: ${{ secrets.OPNSENSE_API_KEY }}
          OPNSENSE_API_SECRET: ${{ secrets.OPNSENSE_API_SECRET }}
        run: |
          echo "Waiting for OPNsense to boot and API to respond..."
          for i in $(seq 1 36); do
            HTTP=$(curl -sk -o /dev/null -w "%{http_code}" \
              -u "${OPNSENSE_API_KEY}:${OPNSENSE_API_SECRET}" \
              "https://${OPNSENSE_HOST}/api/reticulum/service/status" 2>/dev/null || echo "000")
            echo "Attempt ${i}/36: HTTP ${HTTP}"
            if [ "$HTTP" = "200" ] || [ "$HTTP" = "401" ]; then
              echo "OPNsense API is up"
              break
            fi
            [ "$i" -eq 36 ] && { echo "OPNsense did not come up in 6 minutes"; exit 1; }
            sleep 10
          done

      - name: Resolve branch name
        id: branch
        run: |
          BRANCH="${{ github.head_ref }}"
          [ -z "$BRANCH" ] && BRANCH="${{ github.ref_name }}"
          echo "name=$BRANCH" >> "$GITHUB_OUTPUT"
          echo "Deploying branch: $BRANCH"

      - name: Deploy plugin to OPNsense
        env:
          SSH_KEY: ${{ secrets.PNSENSE_SSH_KEY }}
          OPNSENSE_HOST: ${{ secrets.OPNSENSE_HOST }}
          BRANCH: ${{ steps.branch.outputs.name }}
          REPO: ${{ github.repository }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/opnsense_key
          chmod 600 ~/.ssh/opnsense_key

          SSH="ssh -i ~/.ssh/opnsense_key -o StrictHostKeyChecking=no -o ConnectTimeout=15"

          $SSH root@"$OPNSENSE_HOST" bash -s << ENDSSH
            set -e
            which git 2>/dev/null || pkg install -y git
            rm -rf /tmp/ci-reticulum
            git clone --recurse-submodules \
              -b "$BRANCH" \
              "https://github.com/$REPO.git" \
              /tmp/ci-reticulum
            cd /tmp/ci-reticulum/net/reticulum
            make install
            sh /usr/local/+POST_INSTALL
            service configd restart
            sleep 3
            echo "Plugin installed successfully"
          ENDSSH

      - name: Run integration tests
        env:
          OPNSENSE_HOST: ${{ secrets.OPNSENSE_HOST }}
          OPNSENSE_API_KEY: ${{ secrets.OPNSENSE_API_KEY }}
          OPNSENSE_API_SECRET: ${{ secrets.OPNSENSE_API_SECRET }}
        run: |
          .venv/bin/pytest tests/ -v --tb=short --junit-xml=test-results.xml

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ github.run_number }}
          path: test-results.xml

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/opnsense_key
